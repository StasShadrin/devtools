# devtools — Mentee Progress Tracker

[![Java CI with Checkstyle and JaCoCo](https://github.com/StasShadrin/devtools/actions/workflows/ci.yml/badge.svg)](https://github.com/StasShadrin/devtools/actions/workflows/ci.yml)

## Технологический стек проекта

### Языки и платформы
- **Java 25 LTS** — основной язык разработки
- **Gradle 9.2.1** — система сборки (через Gradle Wrapper)

### Инструменты качества кода
- **Checkstyle** — статический анализ стиля кода
   - Конфигурация: `config/checkstyle/checkstyle.xml`
   - Запуск: `./gradlew checkstyleMain`
- **JUnit 5** — фреймворк тестирования
   - Запуск: `./gradlew test`

### CI/CD
- **GitHub Actions** — автоматическая проверка PR
   - Checkstyle на каждый коммит
   - Тесты на каждый коммит
   - Конфигурация: `.github/workflows/`

### Правила кода
- Стиль: Google Java Style Guide (через Checkstyle)
- Коммиты: Conventional Commits (`feat:`, `fix:`, `docs:`)
- Ветки: `feature/DVT-X` для задач, `master` — основная
- Pull Request: обязателен для слияния в master

## Quick Start

1. Убедись, что установлены **JDK 25** и **Gradle** (рекомендуется использовать Wrapper).
2. Собери и запусти приложение:
   ```bash
   ./gradlew run
3. Запусти автоматические тесты:
   ```bash
   ./gradlew test

## Описание

Проект демонстрирует использование record в Java 25 для отслеживания прогресса менти по программе обучения.  
Основной класс: ru.mentee.power.ProgressDemo.  
Содержит логику расчёта готовности к спринту на основе отработанных часов.

## Структура MenteeProgress

| Поле                     | Тип      | Описание                      |
|--------------------------|----------|-------------------------------|
| `menteeName`             | `String` | Имя менти                     |
| `sprintNumber`           | `int`    | Номер спринта                 |
| `plannedHoursPerWeek`    | `int`    | Количество затраченных часов  |


## Методы

- `summary()` — возвращает строку вида `"Sprint '№' -> 'имя менти': planned 'время' h"`.
- `readyForSprint()` — возвращает `Status: sprint ready/backlog first`.

## Правило веток: feature/DVT-X

Все фичи и задачи разрабатываются в отдельных ветках по шаблону:  
**`feature/DVT-<номер>`**

Примеры:
- `master` — основная (стабильная) ветка
- `feature/DVT-3` — ветка для реализации задачи DVT-3

## Git локальный цикл: шаги и команды

1. **Настройка пользователя и проверка Git в IDEA**
   - В терминале:
     ```bash
     git config --global user.name "Имя Фамилия"
     git config --global user.email "student@example.com"
     git config --list | grep user
     ```
   - В IntelliJ IDEA:  
     `Settings (Ctrl+Alt+S) → Version Control → Git → Test`

2. **Инициализация репозитория**
   - Через UI: правый клик по корню проекта → **Git → Initialize Repository**

3. **Первый коммит в ветке `master` (через CLI)**
   ```bash
   git add .gitignore README.md
   git status
   git commit -m "Добавить локальный шаблон и правило веток"
   ```

4. **Создание и переключение на ветку задачи**
   - Через UI: Git Branches popup → New Branch → feature/DVT-3 → Checkout
   - Проверка через CLI:  
     ```bash
     git branch --show-current  # ожидаем: feature/DVT-3

5. **Коммит изменений в коде (через CLI)**
   - Изменить ProgressDemo.java (например, добавить вывод имени ветки)
   - Выполнить:
     ```bash
     git add src/main/java/ru/mentee/power/ProgressDemo.java
     git commit -m "Добавить вывод ветки в ProgressDemo"
     git log --oneline
     ```
     
6. **Коммит изменений в документации (через Commit Tool Window)**
   - Обновить README.md (раздел «Git локальный цикл»)
   - Открыть Commit Tool Window (Alt+0)
   - Ввести сообщение: Обновить README для локального Git → нажать Commit

7. **Проверка истории**
   - Выполнить:
     ```bash
     git log --oneline
     git status
     ```

## Правило «git status clean»

1. **Проверка индекса**
    - Выполнить:
     ```bash
     git status
     ```
    - Убедиться, что мусор не попадает в изменения
2. **Проверка .gitignore в соответствии с паттерном**

       #Gradle Wrapper
       .gradle/
       build/
       !gradle/wrapper/gradle-wrapper.jar
       !gradle/wrapper/gradle-wrapper.properties

       #IntelliJ IDEA
       .idea/
       *.iml
       out/
3. **Проверьте фильтрацию паттернов (после правки .gitignore)**
   - Выполнить:
   ```bash
     git check-ignore -v .DS_Store || true
     git check-ignore -v .idea/workspace.xml || true
    ```
4. **Удалите мусор из индекса (без удаления с диска)**
   - Выполнить:
    ```bash
     git rm -r --cached .idea build out
    ```
5. **Сделайте санитарный коммит и проверьте историю/дифф**
   - Выполнить:
   ```bash
    git commit -m "Очистить репозиторий; обновить .gitignore"
    git log --oneline -n 1
    git diff --name-status HEAD~1..HEAD
   ```
6. **Проверить по правилу «Перед push: git status clean»**

## Сценарий ручной проверки DVT-7

### Запуск приложения
1. Откройте Gradle Tool Window (View → Tool Windows → Gradle)
2. Выполните: devtools → Tasks → application → run
3. Ожидаемый вывод в Run Tool Window:
   Суммарно: пройдено 25 из 36 уроков, осталось 11 уроков

### Запуск тестов
1. Откройте Gradle Tool Window
2. Выполните: devtools → Tasks → verification → test
3. Ожидаемый вывод: BUILD SUCCESSFUL, все тесты зелёные

### Отладка через Debug
1. Установите breakpoint на строке цикла while в ProgressTracker.calculateProgress
2. Запустите Debug: кликните правой кнопкой на main → Debug 'ProgressTracker.main()'
3. Используйте Step Over (F8) для прохождения итераций
4. Проверьте Variables: counter, remainingHours должны изменяться корректно
5. Используйте Evaluate Expression (Alt+F8): вычислите remainingLessons * 2
6. Ожидаемый результат Evaluate: 14 (для completedLessons=5, totalLessons=12)

### Что делать при ошибках
- Если вывод некорректен: проверьте логику цикла через Debug
- Если тесты красные: откройте вывод теста, найдите AssertionError, скорректируйте метод
- Если Debug не останавливается: убедитесь, что breakpoint установлен (красный кружок)  

## Кодстайл-гайд проекта devtools

Проект следует правилам Google Java Style Guide с адаптацией.
Автоматическая проверка: ./gradlew checkstyleMain

### 1. Именование методов: camelCase

До:    public void add_student(Student s) { }
После: public void addStudent(Student student) { }

Почему: Java Convention требует camelCase для методов.
Источник: https://google.github.io/styleguide/javaguide.html#s5.3-camel-case

### 2. Пробелы после if/for/while

До:    if(condition) {
После: if (condition) {

Почему: улучшает читаемость, отделяет ключевое слово от выражения.
Источник: Oracle Code Conventions — Whitespace

### 3. Длина строки: максимум 120 символов

До:    public List getStudentsFromSpecificCityWithVeryLongName...
После: public List getStudentsByCity(String city) {

Почему: длинные строки затрудняют чтение в редакторе и при code review.
Источник: https://google.github.io/styleguide/javaguide.html#s4.4-column-limit

### 4. Порядок импортов

До:    import java.util.List; import java.util.ArrayList; import java.io.File;
После: import java.io.File; import java.util.ArrayList; import java.util.List;

Почему: алфавитный порядок упрощает поиск импортов.
Источник: IntelliJ IDEA → Code → Optimize Imports

### 5. Фигурные скобки для if

До:    if (condition) doSomething();
После: if (condition) { doSomething(); }

Почему: скобки обязательны даже для однострочных блоков.
Источник: https://google.github.io/styleguide/javaguide.html#s4.1.1-braces-always-used

# CI-пайплайн настроен

## Code Review Checklist

Используйте этот чеклист для само-ревью перед запросом ревью у ментора:

### Функциональность
- [ ] Код решает поставленную задачу полностью
- [ ] Обработаны граничные случаи (null, пустые данные, экстремальные значения)
- [ ] Обработка ошибок реализована корректно

### Тесты
- [ ] Добавлены тесты для нового функционала (или обновлены существующие)
- [ ] Все тесты проходят локально: `./gradlew test`
- [ ] Покрыты позитивные и негативные сценарии
- [ ] JaCoCo coverage ≥ 80% для нового кода

### Читаемость и стиль
- [ ] Имена переменных, методов и классов отражают назначение
- [ ] Нет дублирования кода (DRY principle)
- [ ] Checkstyle проходит без ошибок: `./gradlew checkstyleMain`
- [ ] Нет закомментированного кода или отладочного вывода (`System.out.println`)

### Документация
- [ ] README обновлён (если добавлена новая функциональность)
- [ ] Публичные методы имеют JavaDoc (если применимо)
- [ ] Примеры использования актуальны
- [ ] Runbook обновлён (если изменились команды запуска/проверки)

### Производительность и безопасность
- [ ] Нет очевидных проблем производительности
- [ ] Нет хардкода паролей, токенов или конфиденциальных данных

## Примеры Code Review комментариев

### Хорошие комментарии (конструктивные)

**Пример 1:**

**Проблема:** Метод `calculateDiscount` (строка 45) имеет 3 вложенных if-else и 40 строк.  
**Почему это важно:** Сложная логика плохо тестируется и тяжело поддерживается.
**Предложение:** Вынести каждое условие в отдельный метод (например, `isEligibleForBonusDiscount()`)
и использовать паттерн Strategy для разных типов скидок.



**Пример 2:**

**Проблема:** Тест `testProcessOrder` (строка 78) проверяет только успешный сценарий.  
**Почему это важно:** Не проверена обработка ошибок при недостаточном балансе.
**Предложение:** Добавить тест `testProcessOrder_InsufficientBalance_ThrowsException()`
с использованием `assertThatThrownBy()`.



### Плохие комментарии (неконструктивные)

**Пример 1:**

Этот код ужасен, полностью переписать.


**Почему плохо:** Нет конкретики (что именно плохо), нет предложения (как исправить),
токсичный тон (демотивирует автора).

**Пример 2:**

Здесь лучше использовать Stream API.


**Почему плохо:** Нет объяснения почему лучше, нет примера как переписать,
неясно какую проблему это решает.

## Результаты само-ревью DVT-9

### Найденные проблемы

#### 1. Забыт отладочный вывод
**Файл:** src\main\java\ru\mentee\power\ProgressDemo.java (строка 13)  
**Проблема:** Оставлен `System.out.println("Debug: ...");`  
**Почему важно:** Отладочный вывод замусоривает логи production-приложения и создаёт впечатление небрежности.  
**Исправление:** Удалить строку или заменить на logger (если логирование настроено).

#### 2. Закомментированный код
**Файл:** src\main\java\ru\mentee\power\devtools\progress\Mentee.java (строка 24)  
**Проблема:** Закомментирована 1 строка.  
**Почему важно:** Закомментированный код создаёт путаницу: непонятно зачем он сохранён и актуален ли.  
Если нужна история изменений — она в Git.  
**Исправление:** Удалить закомментированный код. Если нужна старая версия — посмотреть в Git History.

#### 3. Добавлен TODO без описания
**Файл:** src\main\java\ru\mentee\power\MenteeProgress.java (строка 19)  
**Проблема:** Оставлен `// TODO:`  
**Почему важно:** Строчка оставлена без описания, может быть рассматривалась как "задание на потом".  
**Исправление:** Удалить строку или добавить задание.


## Информационный поиск — результаты DVT-11

### Запросы и источники

| № | Запрос                                | Операторы                                                         | Официальный источник                                                                                                               | Альтернатива                                                                                                     | Статус | Дата проверки |
|---|---------------------------------------|-------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------|--------|---------------|
| 1 | Lombok в Maven Central (Gradle Short) | site:search.maven.org "lombok" OR site:mvnrepository.com "lombok" | https://central.sonatype.com/artifact/org.projectlombok/lombok/1.18.30/overview                                                    | https://mvnrepository.com/artifact/org.projectlombok/lombok/1.18.30                                              | 200 OK | 21.12.2025    |
| 2 | Java Stream API документация          | site:docs.oracle.com "stream api" intitle:api java 21             | https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/stream/Stream.html?spm=a2ty_o01.29997173.0.0.19a25171adJLY2 | https://docs.oracle.com/en/middleware/standalone/coherence/15.1.1/develop-applications/using-repository-api.html | 200 OK | 21.12.2025    |
| 3 | горячие клавиши IntelliJ IDEA         | site:www.jetbrains.com/help "keymap" "intellij idea"              | https://www.jetbrains.com/help/idea/settings-keymap.html                                                                           | https://tproger.ru/digest/ide-hotkeys                                                                            | 200 OK | 21.12.2025    |

### AI-промпты и сравнение ассистентов

#### Промпт 1: План решения

**Задача**: Нужно добавить валидацию email в класс Student  
**Контекст**: Java 25, у меня есть класс Student с полем email (String), проект на Gradle  
**Ограничения**: без использования регулярных выражений на данном этапе, простая проверка наличия @ и точки  
**Что мне нужно от тебя**: план из 3-5 шагов, объяснение "почему именно так", НЕ пиши код — я реализую сам  
**Критерии успеха**: валидация отклоняет пустые строки, строки без @, строки без точки после @  

**AI-1 [deepseek](https://chat.deepseek.com/):**  
План добавления валидации email в класс Student
1. Определить место для валидации: сеттер (setter) или конструктор
* Почему: Поле email, скорее всего, приватное (private). Это значит, что его изменение должно контролироваться. Добавление проверки в сеттер (setEmail) гарантирует, что любое присваивание нового значения (через student.setEmail("...") или из кода конструктора) будет проходить через один и тот же механизм проверки. Это предотвращает попадание в объект некорректных данных.
* Альтернатива: Если основное присваивание email происходит при создании объекта, логично добавить проверку прямо в конструктор, принимающий email. Но сеттер обеспечивает более универсальный подход.

2. Разработать логику проверки внутри выбранного метода (конструктора/сеттера)
* Почему: Валидация должна быть строгой и последовательной. Логика будет идти по принципу "ошибка - как можно раньше":
1. Проверить, что строка не null и не пустая. Это базовая проверка целостности данных.
2. Найти позицию символа '@' с помощью метода String.indexOf('@').
3. Проверить, что '@' присутствует (индекс > -1) и он не является первым символом (логика: должна быть часть имени пользователя до '@').
4. Найти позицию символа '.', но только в части строки ПОСЛЕ символа '@'. Для этого используйте String.indexOf('.', indexOfAt + 1), где indexOfAt — позиция '@'.
5. Проверить, что точка найдена после '@' (индекс > indexOfAt) и что между '@' и точкой есть хотя бы один символ, а также что точка не является последним символом строки.
* Ключевой момент: Проверка точки после '@' критически важна, так как "@." или "test@com" — невалидны, а "test@domain.com" — валиден.

3. Определить реакцию на невалидные данные: выбрасывание исключения
* Почему: Это самый чистый и идиоматичный для Java способ сообщить об ошибке. Сеттер/конструктор не может молча игнорировать неверный ввод — это создаст объект в некорректном состоянии. Нужно использовать непроверяемое (unchecked) исключение, например, IllegalArgumentException.
* Что делать: В случае провала любой из проверок (п.2) немедленно выбрасывать new IllegalArgumentException("Подробное сообщение об ошибке"). Сообщение должно быть информативным ("Email не может быть пустым", "Email должен содержать '@'", "В доменной части после '@' должна быть точка" и т.д.).

4. Протестировать валидацию на граничных случаях
* Почему: Простая логика может иметь скрытые ошибки. Нужно убедиться, что реализация работает не только на "хороших" данных, но и отклоняет "плохие" именно так, как задумано.
* Какие кейсы проверить:
* null, "", " " (пустая строка или пробелы) -> ошибка.
* student (нет @) -> ошибка.
* student@ (нет точки после @) -> ошибка.
* student@domain (точки нет) -> ошибка.
* student@domain. (точка в конце) -> ошибка (домен не может заканчиваться точкой).
* @domain.com (нет части до @) -> ошибка.
* student.domain.com (@ перед точкой, но точки в домене нет?) -> ошибка.
* student@.com (точка сразу после @) -> ошибка (должен быть хотя бы один символ между @ и .).
* valid.student@domain.com (точка в части до @ — это допустимо) -> УСПЕХ.
* student@sub.domain.com (несколько точек после @ — это допустимо) -> УСПЕХ.

5. (Опционально, но рекомендуется) Обновить документацию
* Почему: Чтобы другие разработчики (или вы сами в будущем) знали о контракте метода. Добавьте JavaDoc к сеттеру/конструктору, явно указав формат валидации и то, что в случае ошибки будет выброшено IllegalArgumentException. Это делает код более предсказуемым и профессиональным.

Критерии успеха будут достигнуты, так как план явно требует проверки на пустоту, наличие @ и наличие точки после @, а также дает механизм для гарантированного отклонения невалидных данных.

**AI-2 [alice](https://alice.yandex.ru/):**
План добавления валидации email в класс Student
1. Добавить метод проверки валидности email
* Почему: изолированная логика валидации упрощает тестирование и повторное использование. Метод будет принимать строку и возвращать boolean — соответствует ли строка базовым критериям.

2. Реализовать три базовые проверки в методе

* строка не пуста (!email.isEmpty());

* содержит символ @ (email.contains("@"));

* после @ есть точка (email.indexOf(".") > email.indexOf("@")).
Почему: эти условия покрывают критерии успеха — отсекают пустые строки, строки без @ и без точки после @. Простая логика без регулярных выражений соответствует ограничениям задачи.

3. Интегрировать валидацию в сеттер поля email
* Почему: централизованная проверка при присвоении значения гарантирует, что поле email всегда содержит валидные данные. Если значение не проходит проверку — выбрасывать исключение (например, IllegalArgumentException с описанием ошибки).

4. Добавить проверку в конструктор класса (если есть параметр email)
* Почему: предотвращает создание объекта с невалидным email. Дублирует логику из сеттера, обеспечивая консистентность на этапе инициализации.

5. Продумать обработку ошибок
* Почему: чёткие сообщения об ошибках (например, «Email не может быть пустым», «Отсутствует символ @», «Точка должна быть после @» ) помогают пользователю/разработчику понять причину отказа. Это улучшает UX и упрощает отладку.

**Сравнение:**  
Ответы обоих AI похожи. Присутствую проверки на включения в строку @. И проверки на null и пустые значения. Ответ AI-1 более структурирован. Выбрал AI-1.

#### Промпт 2: Проверка кода

**Код для проверки:**
```java
package ru.mentee.power.devtools.progress;

/**
 * Запись, представляющая mentee (ученика) с его прогрессом.
 * Содержит информацию об имени, городе, цели и прогрессе в уроках.
 *
 * @param name имя mentee
 * @param city город mentee
 * @param goal учебная цель mentee
 * @param completedLessons количество пройденных уроков
 * @param totalLessons общее количество уроков
 */
public record Mentee(String name,
                     String city,
                     String goal,
                     int completedLessons,
                     int totalLessons) {

    /**
     * Компактный конструктор для проверки корректности данных.
     */
    public Mentee {
        if (completedLessons < 0 || totalLessons <= 0 || completedLessons > totalLessons) {
            throw new IllegalArgumentException("Некорректные значения прогресса");
        }
    }
}
```

**Что проверить:**
1. Логические ошибки
2. Соответствие Code Conventions
3. Производительность

**AI-1 [deepseek](https://chat.deepseek.com/):**  

Логические ошибки:  
✅ Корректно проверены граничные условия (отрицательные значения, превышение completed над total)  
✅ Учтён edge case с totalLessons <= 0 (не может быть нуля или отрицательного общего количества уроков)  

Code Conventions (Java Style):  
✅ Record соответствует современным Java conventions (Java 14+)  
✅ Параметры record расположены правильно (каждый на новой строке при длинном списке)  
✅ Javadoc оформлен корректно  
⚠️ Можно было бы добавить валидацию для name/city/goal на null/пустоту, но это зависит от требований  

Производительность:  
✅ Record по своей природе эффективнее классов (неизменяем, генерирует оптимальные equals/hashCode/toString)  
✅ Проверки в компактном конструкторе минимальны и выполняются один раз при создании  
✅ Нет накладных расходов на наследование или избыточную логику  

Общая оценка: Код качественный, соответствует best practices для records. Единственное возможное улучшение — добавление null-валидации для строковых полей, если это требуется бизнес-логикой.

**AI-2 [alice](https://alice.yandex.ru/):**  

1. Логические ошибки:

* Нет критических логических ошибок. Проверка в компактном конструкторе корректно отсеивает недопустимые состояния (отрицательные пройденные уроки, нулевое/отрицательное общее число уроков, превышение пройденных над общим количеством).

2. Code Conventions:

* В целом соответствует стандартам: корректное имя класса, параметры записи, документация.

* Незначительный недочёт: в Java‑документации принято указывать @param для каждого параметра отдельно (в данном случае они объединены в один блочный комментарий).

3. Производительность:

* Нет проблем с производительностью. Запись (record) — легковесная структура, компактный конструктор выполняет только базовые проверки без ресурсоёмких операций.

**Сравнение:**  
Опять же AI-1 более структурирован, выбор в пользу него.

## Личный глоссарий терминов Dev Tools

### Структура глоссария

Каждый термин содержит:
- **RU / EN** — русское и английское название
- **Определение** — краткое (1-2 предложения) объяснение термина
- **Контекст использования** — где и когда применяется
- **Пример** — конкретное применение в коде/команде/документации
- **Источник** — ссылка на официальную документацию

---

### Категория: Java-экосистема

#### JDK — Java Development Kit

**Определение:**  
Development environment for building applications using the Java programming language. Includes compiler (javac), archiver (jar), documentation generator (javadoc), and other tools.

**Контекст использования:**  
JDK необходим для компиляции Java-кода в байт-код и создания исполняемых JAR-файлов. Без JDK невозможно собрать Java-проект.

**Пример:**  
После установки JDK выполняем `java -version` для проверки версии. В IntelliJ IDEA настраиваем Project SDK: File → Project Structure → Project → SDK → выбираем JDK 25.

**Источник:** https://docs.oracle.com/en/java/javase/21/docs/

---

#### JRE — Java Runtime Environment

**Определение:**  
Среда выполнения Java, необходимая для запуска скомпилированных Java-приложений. 
Включает виртуальную машину Java (JVM), базовые библиотеки классов (Java API) и другие компоненты, но не содержит инструментов разработки (таких как компилятор javac).

**Контекст использования:**  
JRE используется на конечных машинах (например, на сервере или у пользователя), где нужно запустить, но не собрать Java-приложение. 
В современных версиях Java (начиная с Java 11) JRE не поставляется отдельно — вместо этого рекомендуется использовать либо полный JDK, либо создавать уменьшённые runtime-образы через jlink.

**Пример:**  
Пользователь скачивает JRE, чтобы запустить JAR-файл:
```bush
java -jar my-app.jar
```
В IntelliJ IDEA Project SDK можно указать JDK, но для запуска через gradlew run достаточно, чтобы в системе была доступна JVM (часть JRE/JDK).

**Источник:** https://docs.oracle.com/en/java/javase/21/docs/specs/man/java.html?spm=a2ty_o01.29997173.0.0.19a25171VSC4Rg

---

#### JVM — Java Virtual Machine

**Определение:**  
Виртуальная машина, которая выполняет байт-код Java и обеспечивает его платформонезависимость. 
JVM загружает .class-файлы, управляет памятью (включая сборку мусора), выполняет JIT-компиляцию и обеспечивает безопасность выполнения.

**Контекст использования:**  
JVM запускается каждый раз, когда вы выполняете java -jar ... или запускаете Java-приложение. 
Она является сердцем Java-платформы и входит в состав как JDK, так и JRE (в старых версиях). 
На одной машине может быть установлено несколько JVM (разных вендоров или версий) — именно к ней привязывается Gradle, IntelliJ IDEA и другие инструменты.

**Пример:**  
Когда вы запускаете приложение через Gradle:
```bush
./gradlew run
```
Gradle использует JVM, указанную в JAVA_HOME или в настройках IDE, чтобы выполнить байт-код из build/classes/.

**Источник:** https://docs.oracle.com/javase/specs/jvms/se21/html/index.html

---

#### Gradle Wrapper — Gradle Wrapper

**Определение:**  
Скрипты (gradlew, gradlew.bat) и файлы конфигурации, которые позволяют запускать Gradle без предварительной установки на машине. 
Wrapper автоматически скачивает указанную версию Gradle и использует её для сборки проекта, обеспечивая единый окружения для всех разработчиков.

**Контекст использования:**  
Gradle Wrapper обязателен в проектах с командной разработкой и CI/CD. 
Он гарантирует, что все участники и сервер сборки используют одну и ту же версию Gradle, независимо от того, какая версия установлена локально. 
Рекомендуется всегда коммитить Wrapper-файлы в Git.

**Пример:**  
В корне проекта выполняем:
```bush
./gradlew build
```
— даже если Gradle не установлен, Wrapper скачает версию из gradle/wrapper/gradle-wrapper.properties и соберёт проект.
Файл gradle-wrapper.properties содержит:
```properties
distributionUrl=https\://services.gradle.org/distributions/gradle-9.2.1-bin.zip
```

**Источник:** https://docs.gradle.org/current/userguide/gradle_wrapper.html?spm=a2ty_o01.29997173.0.0.19a25171VSC4Rg

---

#### Build Tool — Инструмент сборки

**Определение:**  
Программное обеспечение, автоматизирующее процесс сборки исполняемого кода из исходных файлов. 
Задачи включают компиляцию, управление зависимостями, запуск тестов, упаковку в артефакты и развёртывание.

**Контекст использования:**  
Программное обеспечение, автоматизирующее процесс сборки исполняемого кода из исходных файлов. 
Задачи включают компиляцию, управление зависимостями, запуск тестов, упаковку в артефакты и развёртывание.

**Пример:**  
В проекте на Gradle команда:
```bush
./gradlew test jacocoTestReport
```
— запускает тесты и генерирует отчёт о покрытии, не требуя ручного управления зависимостями или порядком шагов.

**Источник:** https://docs.gradle.org/current/userguide/building_java_projects.html?spm=a2ty_o01.29997173.0.0.19a25171VSC4Rg

---

#### Dependency — Зависимость

**Определение:**  
Внешняя библиотека или модуль, от которого зависит проект для своей компиляции, тестирования или выполнения. 
Зависимости могут быть прямые (указанные явно) или транзитивные (зависимости зависимостей).

**Контекст использования:**  
Dependency используется в каждом Java-проекте для подключения готовых решений: тестовых фреймворков (JUnit), утилит (AssertJ), логгирования (SLF4J) и т.д. 
Build tool (Gradle, Maven) автоматически загружает зависимости из репозиториев (например, Maven Central) и управляет их версиями.

**Пример:**  
В build.gradle зависимость на AssertJ указывается так:
```groovy
dependencies {
    testImplementation 'org.assertj:assertj-core:3.24.2'
}
```
После этого в тестах можно использовать класс Assertions.assertThat.

**Источник:** https://docs.gradle.org/current/userguide/resolution_rules.html

---

#### Artifact — Артефакт

**Определение:**  
Исполняемый или распространяемый файл, сгенерированный в результате сборки проекта. 
Артефакты могут включать JAR-, WAR-, ZIP-файлы, отчёты, Docker-образы и другие выходные продукты, готовые к развёртыванию или публикации.

**Контекст использования:**  
Artifact создаётся на финальных этапах CI/CD-пайплайна и используется для развёртывания на сервере, публикации в репозитории (например, Maven Central) или передачи QA-команде. 
В Gradle артефакты генерируются задачами вроде jar, war или assemble.

**Пример:**  
После выполнения:
```bash
./gradlew jar
```
В папке build/libs/ появляется файл devtools-1.0.jar — это и есть артефакт.
В build.gradle его можно настроить:
```groovy
jar {
   archiveBaseName = 'mentee-progress'
   archiveVersion = '1.0'
}
```

**Источник:** https://docs.gradle.org/current/userguide/publishing_maven.html?spm=a2ty_o01.29997173.0.0.19a25171VSC4Rg

---

### Категория: Инструменты разработки

#### Git — Git

**Определение:**  
Распределённая система контроля версий, предназначенная для отслеживания изменений в исходном коде, совместной работы и управления историей проекта. 
Git позволяет создавать ветки, фиксировать коммиты, сливать изменения и откатывать ошибки без потери данных.

**Контекст использования:**  
Git используется на всех этапах разработки: от локального написания кода до интеграции в CI/CD-пайплайны и публикации в удалённых репозиториях (GitHub, GitLab, Bitbucket). 
Он является стандартом де-факто в современной разработке и обязателен для работы в команде.

**Пример:**  
Разработчик создает feature-ветку, вносит изменения и отправляет их на ревью:
```bash
git checkout -b feature/DVT-5
git add .
git commit -m "Добавить .gitignore и очистить репозиторий"
git push origin feature/DVT-5
```

**Источник:** https://git-scm.com/book/en/v2?spm=a2ty_o01.29997173.0.0.19a25171VSC4Rg

---

#### IDE — Integrated Development Environment

**Определение:**  
Интегрированная среда разработки — программное приложение, объединяющее в одном интерфейсе редактор кода, отладчик, инструменты сборки, 
управление версиями и другие средства для написания, тестирования и отладки программного обеспечения.

**Контекст использования:**  
IDE используется разработчиками ежедневно для повышения продуктивности: благодаря автоимпорту, подсветке синтаксиса, 
рефакторингу, навигации по коду и интеграции с Gradle/Maven/Git. 
В Java-разработке популярные IDE: IntelliJ IDEA, Eclipse, VS Code с расширениями.

**Пример:**  
В IntelliJ IDEA можно:

* Нажать Ctrl+Shift+T, чтобы автоматически создать тест для класса,
* Выполнить Refactor → Rename (Shift+F6), чтобы безопасно переименовать переменную во всём проекте,
* Запустить ./gradlew run прямо из Gradle Tool Window без терминала.

**Источник:** https://www.jetbrains.com/idea/features/?spm=a2ty_o01.29997173.0.0.19a25171VSC4Rg

---

#### SDK — Software Development Kit

**Определение:**  
Набор инструментов, библиотек, документации и примеров кода, предоставляемый для разработки приложений под определённую платформу, 
язык или фреймворк. SDK включает компиляторы, отладчики, API и часто среду выполнения.

**Контекст использования:**  
SDK необходим на этапе разработки, чтобы писать, собирать и тестировать код. 
В Java-мире JDK (Java Development Kit) — это и есть SDK для языка Java. Аналогично существуют SDK для Android, iOS, AWS, GitLab API и т.д. 
В IntelliJ IDEA указание Project SDK определяет, с помощью какого набора инструментов будет компилироваться проект.

**Пример:**  
В build.gradle можно указать целевую версию Java через toolchain:
```groovy
java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(25)
    }
}
```
IDEA при этом требует, чтобы в настройках проекта был выбран JDK 25 как Project SDK:
File → Project Structure → Project → SDK → JDK 25.

**Источник:** https://docs.oracle.com/en/java/javase/25/docs/api/index.html

---

#### Repository — Репозиторий

**Определение:**  
Хранилище, в котором сохраняется исходный код проекта, его история изменений и метаданные. 
В системах контроля версий (например, Git) репозиторий содержит все коммиты, ветки, теги и конфигурацию, необходимые для воссоздания любого состояния проекта.

**Контекст использования:**  
Repository используется как локальное (на машине разработчика) и удалённое (на GitHub, GitLab, Bitbucket) хранилище кода. 
Он лежит в основе совместной разработки: разработчики клонируют репозиторий, создают ветки, отправляют изменения и синхронизируются через push/pull. 
В Gradle репозиториями также называют источники зависимостей (например, mavenCentral()), откуда загружаются библиотеки.

**Пример:**  
В build.gradle указываются репозитории для скачивания зависимостей:
```groovy

repositories {
    mavenCentral()
    gradlePluginPortal()
}
```
А в Git репозиторий клонируется командой:
```bash
git clone https://github.com/user/devtools.git
```

**Источник:** https://git-scm.com/book/en/v2/Git-Basics-Getting-a-Git-Repository?spm=a2ty_o01.29997173.0.0.19a25171VSC4Rg

---

#### Commit — Коммит

**Определение:**  
Атомарная операция в системе контроля версий, фиксирующая снимок изменений в файлах проекта. Каждый коммит содержит изменения (diff), 
автора, временную метку и уникальный хеш (например, a1b2c3d), что позволяет точно восстановить состояние проекта на любой момент времени.

**Контекст использования:**  
Commit используется разработчиком для сохранения логически завершённых изменений: после реализации функции, исправления бага или рефакторинга. 
Хорошая практика — делать маленькие, сфокусированные коммиты с понятным сообщением. 
Коммиты лежат в основе code review, отката ошибок, бисекции и CI/CD: каждый push запускает проверки именно по новым коммитам.

**Пример:**  
Создание коммита в терминале:
```bash
git add src/main/java/ru/mentee/power/MenteeProgress.java
git commit -m "feat: добавить record MenteeProgress и методы summary/readyForSprint"
```
В IntelliJ IDEA — через вкладку Commit, где можно выбрать файлы, написать сообщение и нажать Commit.

**Источник:** https://git-scm.com/docs/git-commit?spm=a2ty_o01.29997173.0.0.19a25171VSC4Rg

---

#### Branch — Ветка

**Определение:**  
Независимая линия разработки в репозитории, позволяющая изолированно вносить изменения, не затрагивая основную кодовую базу. 
Каждая ветка указывает на определённый коммит и может развиваться параллельно с другими ветками.

**Контекст использования:**  
Branch используется для реализации новых функций (feature/*), исправления багов (hotfix/*), подготовки релизов (release/*) или 
поддержки стабильной версии (main/master). После завершения работы ветка сливается (merge) в целевую (обычно main) через Pull Request или Merge Request. 
Это ключевой элемент GitFlow и других стратегий ведения кода.

**Пример:**  
Создание и переключение на feature-ветку:
```bash
git checkout -b feature/DVT-5
```
После коммитов и пуша:
```bash
git push origin feature/DVT-5
```
— в GitHub открывается Pull Request для ревью и последующего слияния в main.

**Источник:** https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell?spm=a2ty_o01.29997173.0.0.19a25171VSC4Rg

---

#### Pull Request — Pull Request

**Определение:**  
Запрос на слияние изменений из одной ветки в другую в системе совместной разработки (GitHub, GitLab и др.). 
Pull Request (PR) — это не просто техническая операция, 
а механизм code review, обсуждения кода, автоматических проверок и принятия решений о включении изменений в основную ветку.

**Контекст использования:**  
PR создаётся после завершения работы в feature-ветке и перед слиянием в main (или develop). 
Он запускает CI-пайплайн (тесты, Checkstyle, JaCoCo), позволяет коллегам оставить комментарии, предложить правки и утвердить изменения. 
Только после прохождения всех проверок и апрува PR можно смержить.

**Пример:**  
После пуша feature-ветки:
```bash
git push origin feature/DVT-5
```
— на GitHub автоматически появляется кнопка «Compare & pull request». 
После нажатия заполняется описание, назначаются ревьюеры, и PR становится виден всей команде. 
Внизу отображаются статусы от GitHub Actions: ✅ build, ✅ test, ✅ coverage.

**Источник:** https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-pull-requests?spm=a2ty_o01.29997173.0.0.19a25171VSC4Rg

---

#### Checkstyle — Checkstyle

**Определение:**  
Инструмент статического анализа кода для Java, который проверяет соответствие исходного кода заданным правилам оформления (coding style) и лучшим практикам. 
Правила могут включать отступы, пробелы, именование, структуру файлов и многое другое.

**Контекст использования:**  
Checkstyle используется в CI/CD-пайплайнах и локальной разработке для обеспечения единообразия кода в команде и предотвращения стилевых ошибок. 
Он интегрируется в Gradle, Maven и IDE (IntelliJ IDEA, Eclipse), 
а также настраивается через XML-файл с правилами (например, Google Java Style или кастомный набор).

**Пример:**  
В build.gradle подключается плагин:
```groovy
plugins {
    id 'checkstyle'
}
```
При запуске:
```bash
./gradlew checkstyleMain
```
— Checkstyle проверит все .java-файлы и выдаст ошибку, если найдёт нарушение, например:
'{' должен находиться в конце предыдущей строки.

**Источник:** https://checkstyle.org/?spm=a2ty_o01.29997173.0.0.19a25171VSC4Rg (Работает с VPN)

---

#### Debug — Отладка

**Определение:**  
Процесс поиска, анализа и устранения ошибок (багов) в программном коде с использованием специальных инструментов, 
позволяющих пошагово выполнять программу, осматривать значения переменных и отслеживать поток выполнения.

**Контекст использования:**  
Debug используется разработчиком при возникновении неожиданного поведения программы: падения с исключением, неверного результата, зависания и т.д. 
Современные IDE (IntelliJ IDEA, VS Code) предоставляют графический отладчик с точками останова (breakpoints), 
просмотром стека вызовов и возможностью оценки выражений (Evaluate Expression).

**Пример:**  
В IntelliJ IDEA:

1. Ставим breakpoint слева от строки кода (красная точка),
2. Запускаем приложение в режиме Debug (значок жука),
3. При остановке наводим курсор на переменную или открываем вкладку Variables,
4. Используем Evaluate Expression (Alt+F8), чтобы проверить значение любого выражения, например: mentee.readyForSprint().

**Источник:** https://www.jetbrains.com/help/idea/debugging-code.html?spm=a2ty_o01.29997173.0.0.19a25171VSC4Rg

---

#### Breakpoint — Точка останова

**Определение:**  
Маркер в исходном коде, который указывает отладчику приостановить выполнение программы в определённой строке. 
В момент останова разработчик может изучить состояние программы: значения переменных, стек вызовов, содержимое объектов и выполнить произвольные выражения.

**Контекст использования:**  
Breakpoint используется при отладке (debugging) для анализа поведения кода в реальном времени. 
Он позволяет «заморозить» программу перед или после интересующей операции, чтобы понять, почему результат отличается от ожидаемого. 
В IDE точки останова устанавливаются кликом слева от номера строки и управляются через панель Debug.

**Пример:**  
В IntelliJ IDEA:

1. Кликаем слева от строки int total = calculateTotalProgress(mentees); — появляется красная точка.
2. Запускаем приложение в режиме Debug.
3. Выполнение останавливается на этой строке до её выполнения.
4. В окне Variables видим текущие значения mentees, а через Evaluate Expression (Alt+F8) можем проверить, например, mentees.size().

**Источник:** https://www.jetbrains.com/help/idea/using-breakpoints.html?spm=a2ty_o01.29997173.0.0.19a25171VSC4Rg

---

### Категория: Процессы и практики

#### Code Review — Code Review

**Определение:**  
Процесс коллективной проверки исходного кода другими разработчиками перед его слиянием в основную ветку. 
Цели ревью — повысить качество кода, выявить баги, обеспечить соблюдение архитектурных и стилевых соглашений, а также передать знания внутри команды.

**Контекст использования:**  
Code Review является обязательным этапом в современных workflow (например, GitFlow или Feature Branch Workflow) и интегрируется в процессы CI/CD. 
Он проводится после создания Pull Request и до мёрджа. 
Хорошее ревью фокусируется не на личности автора, а на коде: читаемости, тестируемости, безопасности и производительности.

**Пример:**  
Разработчик открывает Pull Request с новой фичей. Коллеги:

1. Комментируют строки кода в GitHub: «Можно ли вынести это условие в отдельный метод для лучшей читаемости?»
2. Проверяют, проходят ли CI-тесты и Checkstyle,
3. Просят добавить тест на граничное значение,
4. После исправлений ставят Approve, и PR мержится в main.

**Источник:** https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/about-pull-request-reviews?spm=a2ty_o01.29997173.0.0.19a25171VSC4Rg

---

#### CI/CD — Continuous Integration / Continuous Delivery (или Deployment)

**Определение:**  
Набор практик и инструментов автоматизации разработки, при котором:

* CI (Continuous Integration) — каждый коммит автоматически собирается, тестируется и проверяется на интеграционные ошибки,
* CD (Continuous Delivery/Deployment) — успешно протестированный код автоматически доставляется в staging или сразу на production.

**Контекст использования:**  
CI/CD используется для ускорения выпуска качественного ПО, снижения рисков и устранения ручных ошибок. 
Он запускается при пуше в ветку или открытии Pull Request и включает этапы: 
сборка → запуск тестов → проверка стиля (Checkstyle) → анализ покрытия (JaCoCo) → публикация артефакта или деплой. 
В open-source и корпоративной разработке CI/CD — стандарт де-факто.

**Пример:**  
В GitHub Actions workflow для Java-проекта:
```yaml
- name: Run tests
  run: ./gradlew test
- name: Verify code coverage
  run: ./gradlew jacocoTestCoverageVerification
```
Если любой шаг падает — Pull Request блокируется красным крестиком, и мёрдж невозможен до исправления.

**Источник:** https://docs.github.com/en/actions/get-started/understand-github-actions?spm=a2ty_o01.29997173.0.0.19a25171VSC4Rg

---

#### Runbook — Ранбук

**Определение:**  
Документ или набор инструкций, описывающий стандартные операции, процедуры и реакции на типовые ситуации в процессе разработки, развёртывания или поддержки системы. 
Runbook служит «дорожной картой» для разработчиков и инженеров, чтобы избежать ошибок и обеспечить единообразие действий.

**Контекст использования:**  
Runbook используется в DevOps-практиках и современной разработке для фиксации инвариантов качества: «перед push — убедись, что git status clean», 
«при падении CI — проверь Checkstyle и покрытие JaCoCo», «как восстановить локальный репозиторий после сбоя». 
Он может храниться в Markdown-файле (RUNBOOK.md), в Wiki репозитория или в системе управления знаниями.

**Пример:**  
В проекте правило из Runbook:

      «Перед push: проверить, что git status показывает clean. Проверять в терминале и в Commit Tool Window в IDEA.»
      Это правило защищает репозиторий от случайных коммитов мусора (.idea/, build/, временных файлов ОС).

**Источник:** https://en.wikipedia.org/wiki/Runbook#:~:text=In%20a%20computer%20system%20or,or%20in%20physical%20book%20form.

---

## Вопросы по сложным терминам

### Вопрос 1:  JDK/JRE/JVM

**Задача:**  
Не могу понять разницу между JDK, JRE и JVM — когда какой нужен?

**Контекст:**  
Изучил определения в Oracle Docs, но практическое применение не ясно. У меня установлен JDK 25, в build.gradle нет упоминания JRE.

**Ограничения:**  
Пробовал поискать на Stack Overflow, но там смешаны примеры для Java 8 и Java 25.

**Ожидаемый результат:**  
Чёткое понимание, когда мне нужен JDK (для компиляции), когда JRE (для запуска), и что делает JVM (исполнение байт-кода).

**Критерии успеха:**  
Могу объяснить коллеге разницу и показать пример: JDK для javac, JRE для java, JVM внутри обоих.

---

### Вопрос 2:  Механизм Pull Request

**Задача:**  
Не понимаю, как именно работает Pull Request: чем он отличается от простого git merge, зачем нужны ревьюеры и как CI/CD связан с PR.

**Контекст:**  
Изучил документацию GitHub по Pull Requests и делал PR в учебных проектах, 
но не до конца ясно, как происходят автоматические проверки и почему нельзя смержить, даже если код «работает локально».

**Ограничения:**  
Пробовал создавать PR без CI — всё мержилось без вопросов. А с JaCoCo и Checkstyle — падает сборка, но не всегда понятно, почему именно.

**Ожидаемый результат:**  
Чёткое понимание, что Pull Request — это не просто технический запрос на слияние, а целый workflow: 
от создания ветки → push → автоматических проверок (CI) → code review → approval → merge. Уметь объяснить, почему CI-статусы влияют на возможность мёрджа.

**Критерии успеха:**  
Могу самостоятельно настроить GitHub Actions, который блокирует мёрдж при падении тестов или низком покрытии, и объяснить коллеге, почему «зелёные галочки» обязательны.

## Ссылки

📚 [DVT-1 — Установка JDK и IntelliJ IDEA, первый запуск](https://mentee-power.xl.ru/learn/eZTCGC3TuEW8P6jDvNRFZw/theory)    
📚 [DVT-2 — Gradle-проект и базовый](https://mentee-power.xl.ru/learn/MCIneBj4KkyH-GIRCspFvA/theory)  
📚 [DVT-3 — Git Essentials: локальный цикл](https://mentee-power.xl.ru/learn/YkPmAouqvkG_WPo9QL1ZrA/theory)  
📚 [DVT-4 — GitHub и первый Pull Request](https://mentee-power.xl.ru/learn/A_btRUb8mkOIhdfHpFvh5g/theory)  
📚 [DVT-5 — Чистый Git‑репозиторий](https://mentee-power.xl.ru/learn/YAyt18jq5Ei8UrJbIjlkVA/theory)  
📚 [DVT-6 — Один цикл и контроль прогресса — освоение Debug](https://mentee-power.xl.ru/learn/sjF69ienA0-9D3WhGYqhuA/theory)  
📚 [DVT-7 — Checkstyle и культура кода — автоматизация стандартов](https://mentee-power.xl.ru/learn/H-BwIbNy-0uWKVNhmmR_xA/theory)  
📚 [DVT-8 — GitHub Actions CI — автоматизация проверок при push и PR](https://mentee-power.xl.ru/learn/rMMhPOjJNEeXw-sQmfJYZQ/theory)  